# 격자안에서 한칸씩 이동하는 DP
# 웰논문제를 복잡하게 섞어놓은 것

#### 어떻게 푸는가 : DP
# 3차원 DP로 풀림
# DP[i][j][k] 로 정의 = k개의 칸에 색칠을 진행했고 마지막으로 방문한 위치를 i,j라 했을 때 색칠된 칸에 잇는 수들 중 최댓값을 구함

# 6번이라고 꼭 정확히 이해할 필요는 없다

#### 점화식 
# 1. 현재칸 색칠할 때
    # 1-1. 왼쪽에서 왔을 때 현재값과 비교해서 최대값중 최소가 되는지 확인
    # 1-2. max(DP[i-1][j][k-1]. grid[i][j])

# 2. 현재칸 색칠하지 않을 때
    # 2-1. 위에서 색칠되어 왔을 때
    # 2-2. 왼쪽에서 색칠되어왔을 때

### 초기조건 : 첫번째 칸에 대해서만 생각하면됨
# 시작위치를 색칠하지 않을 경우
    # dp[0][0][0] = INT_MIN
# 시작위치 색칠 하는 경우
    # dp[0][0][1] = grid[0][0]

### 코드가 조잡한 이유 : 런타임에러 피하기 위해 


### 제로패딩 : 0번지에서 적절한 값을 넣는것을 zero padding이라 함
# 0번지에서 시작할지 1번지에서 시작할지
# 1부터 n까지 해결하는게 좋음
# i가 0이고 j가 0인곳에 INT_MAX 채워주기

# 제로패팅을 깔끔하게 잡아주면 잘 풀린다
# 별도의 코너케이스대한 별도 처리없이 
# 논리정연한 사람들의 풀이를 보면 if문 처리가 없다



# 백트레킹으로 하면 2의 100승 
# DP의 초기값설정이 제일 어려움

# 이정도 난이도 문제 안나옴!
# 네카라쿠배는 웰논문제 나온다고 생각하는데
# 이 모의고사는 웰논문제가 없음


## DP실력 늘리기
# 1. 상태를 직접 생각하면서 이것저것 만들어보기
# 2. 상태를 떠올리기 어렴다
# 3. 어떤문제든 떠올렸을 때 왜 안되는지 생각하는게 중요
# 4. 한번 더 풀어보고, 난이도에 맞는 DP문제 여러개 풀어보는게 중요
# 5. 질문 많이하기
# 6. 메모이제이션 연습하지 말고 타블레이션 연습하기



# 문제집 없이 자동으로 다음 문제 추천해주는 시스템 개발하실것임
# 해설을 없앨것

# 처음에 완탐으로 점수 먹는게 중요