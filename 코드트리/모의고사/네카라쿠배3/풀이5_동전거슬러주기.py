# 꼬아서 낸 문제
# 동전을 한개씩만 써서 만들 수 있다
# 동전의 개수가 무한한 경우엔 DP사용

##### 1.백트레킹 : 
# 부분수열 문제랑 똑같음
# 개념을 아는데 풀지를 못했어! => 하지만 시간초과뜸 


### 2차원 DP
# DP 풀이를 원하셨음
# 배낭 채우기 문제랑같음
# 난 못품 ㅎ,,

# https://www.codetree.ai/missions/2/problems/knapsack/description
# 배낭 채우기에서 value값이 전부 1인거랑 이 문제랑 똑같음
# 동등한 상황은?
# 지금까지 고려한 동전의 위치 (i)
# 지금까지 선택한 동전의 합 (j)
# 지금까지 사용한 동전의 개수를 줄이 (value)는 DP를 세우면 좋겠다
# DP[i][j] = i번까지 고려해봤고 지금까지 고른 동전의 합이 j였을 때 가능한 최소 동전의 수

# 첫번째 후보 = DP[i][j] = DP[i-1][j-coins[i]] + 1
# 현재 동전 +  지금까지 구한 수 = m값

# dp[i][j] = dp[i-1][j]
# 냅색? 은 어려운 DP


### 1차원 DP
# 이 문제는 대부분 이 풀이로 푼다
# 동전의 개수가 무한한 경우부터 예시로 함
# for문을 반대로 돌면 동전을 한번만 써서 최소개수를 구할수있는 DP로 바뀐다,,,!!!
# 이게왜돼?!

# 동전의 세계는 어렵다