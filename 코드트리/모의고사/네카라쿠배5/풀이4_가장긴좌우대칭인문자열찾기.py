# 유명한 문제 : 팰린드롬

# 첫번째 풀이는 완탐
# 원래 리스트와 뒤집은 리스트가 같은지 확인
# 나이브하고 시간초과 나옴
# 1000이면 n의 3승은 안된다


# 두번째 풀이 
# 중심점을 잡고 확장해 나가면서 범위가 넘어가면 멈추는 방식으로
# O(N)만에 알 수 있다
# 중심점 찾는 시간복잡도는 O(N)이기 때문에 O(N^2)만에 
# 모든 팰린드롬을 찾을 수 있다
# 홀수인경우와 짝수인 경우 나눠서 찾을 수 있따


# 3번 풀이 ㅣ DP
# dp[i][j] = 처음 i와 끝 j가 같은지 확인 (양쪽경계가 같은지 확인)
# dp에서 중요한건 값이 순서대로 쌓여햐한다는 것
# 다들 메모이제이션 언제쓰는지 물어본다
# 메모이제이션으로만 코드가 짭게 짜지는 문제가 있다 바로 이 문제
# 순서대로 dp값을 구할때

# 초기조건 : 길이가 1인 경우 
# dp[1][1] = 1
# dp[1][2] = 1
# dp[1][3] = 1
# dp[1][4] = 1
# dp[1][5] = 1


# 길이가 2인 경우 까지 초기화
# dp[1][2] = 0
# dp[2][3] = 1
# dp[3][4] = 0
# dp[4][5] = 0
# dp[5][6] = 0

# 길이가 3인경우부터 시작한다

# 길이가 3인 경우
# dp[1][3] = 0
# dp[2][4] = 0
# dp[3][5] = 0
# dp[4][6] = 0

# 길이가 4인 경우
# dp[1][4] = 1
# dp[2][5] = 0
# dp[3][6] = 0

# 팰린드롬들 유형은 비슷한데 
# 전부 같은 풀이로 풀리진 않는다


# 문자열을 뒤집고 뒤집은 문자열이랑 원래 문자열이랑 가장 긴 똑같은 문자열을 구하면 반례가 생길 것 같은데 어떤 반례가 생길까요?
# baabcdfcbaab라고 하면 뒤집는다면
# baabcfdcbaab가 되고
# 둘을 비교했을 때 같은 문자는 cbaab가되버린다!
# 반례가 생김


### 타블레이션 연습이 훨씬 중요
# 타블레이션 완벽하게 했다면 메모이제이션 해보기
# 바텀업일 경우 길이가 확장되는 문제가 나오면 메모이제이션으로 풀면 쉽게 풀림
# 트리디피 비트마스킹 디피는 우선순위가 낮다





######### 메모이제이션 풀이
# 변수 선언 및 입력:
input_str = input()

# dp[start][end] : 문자열의 start부터 end까지의 부분문자열이 좌우대칭인지 여부
dp = [
    [-1] * len(input_str)
    for _ in range(len(input_str))
]


def is_palindrom(s, e):
    # 종료조건  
    if s == e:
        return True

    if s == e + 1:
        return input_str[s] == input_str[e]

    # 똑같은 값이 있었으면
    if dp[s][e] != -1:
        return dp[s][e]

    ##############
    # 계산한다
    dp[s][e] = is_palindrom(s+1, e-1) and input_str[s] == input_str[e]
    return dp[s][e]



ans = 0
   

# 모든 부분문자열에 대하여 좌우대칭인지를 확인한 후,
# 가장 긴 좌우대칭인 부분 문자열을 저장합니다.
for start in range(len(input_str)):
    for end in range(start, len(input_str)):
        if is_palindrom(start, end):
            ans = max(ans, end - start + 1)

print(ans)