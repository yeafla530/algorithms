# 00.완주하지 못한선수_풀이 (해시)

* n: 10만 이하

* O(n), O(nlogn)정도 착안해야함

* 동명이인이 존재 => set 비교사용 못함

* participant의 각 이름의 개수를 세서 completion 각 이름의 개수와 비교
* 이름에 대해 `몇번이나 수를 나타내야하는지` 표시 => hash가 적합
* 이름이 아닌 번호가 주어졌더라면 `선형배열`을 사용했을 것
* 문자열로 접근할 수 있는 좋은 자료구조 : `해시`



### 해시

![image-20220711162039784](.\images\image-20220711162039784.png)

* 해시 한칸을 해시 버킷이라고 함

![image-20220711162105006](.\.\images\image-20220711162105006.png)

* 같은 해시 버킷을 쓰게 되는 경우 => 충돌이 일어남

* 아래 그림처럼 버킷을 하나 더 만들어서 충돌해결 가능

  ![image-20220711162119230](.\images\image-20220711162119230.png)



## 풀이

1. participant 이름을 센다
2. completion에서 이름을 비교하며 개수를 빼준다
3. 남겨진 1개의 이름을 return 한다

![image-20220711162326329](.\images\image-20220711162326329.png)



### 새로 알게된 것

1. dictionary.get(x)
   
   * .get(x, 디폴트값) : 딕셔너리의 value값 return하고 디폴트값을 지정할 수 있음
2. items()
   * .items() : dictionary의 경우 key와 value 도출 가능
   * for (k, v) in dict.items() => key: k, value: v로 출력됨

3. 정렬의 시간복잡도 : O(NlogN)

   

# 01.체육복_풀이 (탐욕법)

* 전체 학생의 수 2 ~ 30명 이하

* 도난당한 학생 수 2명이상 n명이하

* ![image-20220711171256462](.\images\image-20220711171256462.png)

  ![image-20220711171315040](.\images\image-20220711171315040.png)		

### 탐욕법 (Greedy)

> 알고리즘의 각 단계에서 그 순간에 최적이라고 생각되는 것을 선택

* 최적해를 찾을 수 있는 문제 => 현재의 선택이 마지막 해답의 최적성을 해치지 않을 때
* 지금 이순간 선택!

* 빌려줄 학생들을 `"정해진순서"`로 살펴야 하고, 이 `"정해진 순서"` 에 따라 우선하여 빌려줄 방향을 정해야함 



## 풀이

* 착안점 : 학생의 수는 기껏해야 30명!
* 학생 수만큼 배열 확보 => 각자 가지고있는 체육복 수를 기록 => 번호 순서대로 `스캔`하면서 빌려줄 관계 정하기



### 방법1

* 맨 앞뒤로 배열의 크기를 늘려준다 (2칸 추가 : 0, n+1)
* 모든 학생의 체육복 수를 1개로 초기화
* reserve에 있는 학생의 체육복 수는2개로
* lost에 있는 학생의 체육복 수는 -1

![image-20220711171940693](.\images\image-20220711171940693.png)

* 2번은 1번에게 체육복을 빌려줌
* 6번은 5, 7에게 빌려줄수있지만 5, 7 둘다 체육복이 존재하기 때문에 패스 



### 복잡도

* 여벌을 가져온 학생 처리 : reserve 길이에 비례

* 체육복 잃어버린 학생 처리: lost길이에 비례

* 체육복 빌려주기 처리: 전체 학생수 (N)에 비례

  => `O(n)`



### 방법 2

* 만약 전체 학생수 매우 크다면? 천만 이상
  * O(n)보다 낮은 복잡도 알고리즘은 어려울듯?
* 그런데 여벌의 체육복을 가져온 학생은 매우 적다면?
  * 여벌의 체육복을 가져온 학생들의 번호(reserve)를 정렬하고
  * 이것을 하나하나 순서대로 살펴보면서
  * `빌려줄 수 있는 다른 학생을 찾아`서 처리(나보다 -1인 학생, +1인 학생 찾기)
  * 정렬 복잡도 O(klogk)지만 매우 적은 경우엔 이 방법을 택하는게 더 좋을 것
  * 빌려줄 수 있는 다른 학생 찾기 => 해시를 적용해 상수시간에 처리

![image-20220711173004155](.\images\image-20220711173004155.png)



### 복잡도

* 여벌 체육복 가져온 학생들 번호 (reserve) 정렬 => O(klogk)
* 체육복 빌려줄 수 있는 학생들 처리 => O(k) x O(1) (앞뒤 학생 체크 => 해시 테이블)
* 전체 알고리즘 시간 복잡도 `O(klogk)`
* 전체n은 매우크지만 reserve의 길이(k)가 매우 적을 때만 적용가능



## 새로 알게된 것

1. 배열 초기화
   * u[i-1:i+1] = [1, 1]



# 02.가장 큰 수 (정렬)

*  숫자를 문자열로 만들어 return

## 방법1 : for

* 빈 문자열로 수를 초기화한다
* 가장 크게 만들수있는 수를 고른다
* 그 수를 현재 수에 이어붙인다
* 모든 수를 다 사용할때까지 반복

![image-20220712153709228](images/image-20220712153709228.png)

* 무조건 크기가 크다고 좋은게 아니다
* 가장 수를 크게 만들 것 = 고르는것은 리스트 길이에 비례,  반복을 목록안에 들어있는 개수만큼 실행 => O(n^2)의 시간복잡도가 걸림
* O(n^2)보다 낫게하는 알고리즘이 정렬 O(nlogn)



## 방법2: 정렬 (더 나은 방법)

1. 빈 문자열로 수를 초기화
2. 수의 목록을 (**크게 만드는것 우선**) 정렬한다
3. 목록에서 하나씩 꺼내 현재 수에 이어붙임
4. 모든 수를 다 사용할 때까지 반복



### 크게 만드는 수의 기준

3 / 32 / 33 / 34

![image-20220712155044672](images/image-20220712155044672.png) 

![image-20220712155136094](images/image-20220712155136094.png)

* 1000까지이므로 4자리만 비교해보면 됨
* 대소 관계 비교를 위한 기준을 마련



## 새로 알게된 것

1. 가장큰 수가 될수 있도록 정렬하는 방법은 모든 숫자를 다 4번씩 반복하게 한 후에 주어지는 수의 자리수만큼 잘라서 비교하는 것이다 (n=1000까지 주어지므로, 4자리 수까지 자름)

   





# 큰수 만들기

* 앞자리에 큰 수가 오는것이 전체를 크게 만든다

  * 따라서 큰 것을 우선해서 담아야한다

  ![image-20220712170543225](images/image-20220712170543225.png)

* 앞자리에서부터 하나씩 골라서 담되, 지금 담으려는 것보다 작은 것들은 도로 뺀다
  * 단 뺄 수 있는 수효에 도달할 때까지만

* 큰 수가 앞자리에, 작은 수가 뒷자리에 놓이도록, (제약조건) 뺄 수 있는 수의 개수

* 주어진 숫자로부터 하나씩 꺼내어 모으되
  * 이때 이미 모아둔 것 중 지금 등장한 것보다 작은 것들은 빼낸다
  * 어디서 어떻게 살펴보아야?
* 이렇게 모은 숫자들을 자릿수 맞추어 반환한다
  * 아직 뺄 개수를 채우지 못한 경우
  * 자릿수는 어떻게 계산하는가?



* 우리가 설계한 알고리즘의 복잡도는 ? **O(n)**
* **탐욕법** : 앞단계(큰걸 앞에 두고 뒤를 쳐다보지 않아도, 앞에 나온게) k개가 채워질 때까지 빼내는게 , 뒷자리의 개수를 정하는 해 (solution)의 최적성에 영향을 주지 않음 
  * 탐욕법 적용가능! 



## 새로 알게된점

1. python에서 삼항 연산자처럼 쓰이는 문법

   ```
   # k>0이면 collect[:-k], 아니면 collected
   collected = collect[:-k] if k > 0 else collected
   ```

   

2. while을 쓴다고 시간복잡도가 무조건 늘어나는 것은 아니다

   아래 코드 같은 경우에는 

   ```
   for i, num in enumerate(number):
       while len(collected) > 0 and collected[-1] < num and k > 0:
       	collected.pop()
   ```

3. enumerate : index와 value 함께 뽑아내고 싶을 때

   ```
   for i, num in enumerate(number):
   ```

   