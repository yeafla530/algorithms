# 00.완주하지 못한선수_풀이 (해시)

* n: 10만 이하

* O(n), O(nlogn)정도 착안해야함

* 동명이인이 존재 => set 비교사용 못함

* participant의 각 이름의 개수를 세서 completion 각 이름의 개수와 비교
* 이름에 대해 `몇번이나 수를 나타내야하는지` 표시 => hash가 적합
* 이름이 아닌 번호가 주어졌더라면 `선형배열`을 사용했을 것
* 문자열로 접근할 수 있는 좋은 자료구조 : `해시`



### 해시

![image-20220711162039784](.\images\image-20220711162039784.png)

* 해시 한칸을 해시 버킷이라고 함

![image-20220711162105006](.\.\images\image-20220711162105006.png)

* 같은 해시 버킷을 쓰게 되는 경우 => 충돌이 일어남

* 아래 그림처럼 버킷을 하나 더 만들어서 충돌해결 가능

  ![image-20220711162119230](.\images\image-20220711162119230.png)



## 풀이

1. participant 이름을 센다
2. completion에서 이름을 비교하며 개수를 빼준다
3. 남겨진 1개의 이름을 return 한다

![image-20220711162326329](.\images\image-20220711162326329.png)



### 새로 알게된 것

1. dictionary.get(x)
   * .get(x, 디폴트값) : 딕셔너리의 value값 return하고 디폴트값을 지정할 수 있음
2. items()
   * .items() : dictionary의 경우 key와 value 도출 가능
   * for (k, v) in dict.items() => key: k, value: v로 출력됨

3. 정렬의 시간복잡도 : O(NlogN)

   

# 01.체육복_풀이 (탐욕법)

* 전체 학생의 수 2 ~ 30명 이하

* 도난당한 학생 수 2명이상 n명이하

* ![image-20220711171256462](.\images\image-20220711171256462.png)

  ![image-20220711171315040](.\images\image-20220711171315040.png)		

### 탐욕법 (Greedy)

> 알고리즘의 각 단계에서 그 순간에 최적이라고 생각되는 것을 선택

* 최적해를 찾을 수 있는 문제 => 현재의 선택이 마지막 해답의 최적성을 해치지 않을 때
* 지금 이순간 선택!

* 빌려줄 학생들을 `"정해진순서"`로 살펴야 하고, 이 `"정해진 순서"` 에 따라 우선하여 빌려줄 방향을 정해야함 



## 풀이

* 착안점 : 학생의 수는 기껏해야 30명!
* 학생 수만큼 배열 확보 => 각자 가지고있는 체육복 수를 기록 => 번호 순서대로 `스캔`하면서 빌려줄 관계 정하기



### 방법1

* 맨 앞뒤로 배열의 크기를 늘려준다 (2칸 추가 : 0, n+1)
* 모든 학생의 체육복 수를 1개로 초기화
* reserve에 있는 학생의 체육복 수는2개로
* lost에 있는 학생의 체육복 수는 -1

![image-20220711171940693](.\images\image-20220711171940693.png)

* 2번은 1번에게 체육복을 빌려줌
* 6번은 5, 7에게 빌려줄수있지만 5, 7 둘다 체육복이 존재하기 때문에 패스 



### 복잡도

* 여벌을 가져온 학생 처리 : reserve 길이에 비례

* 체육복 잃어버린 학생 처리: lost길이에 비례

* 체육복 빌려주기 처리: 전체 학생수 (N)에 비례

  => `O(n)`



### 방법 2

* 만약 전체 학생수 매우 크다면? 천만 이상
  * O(n)보다 낮은 복잡도 알고리즘은 어려울듯?
* 그런데 여벌의 체육복을 가져온 학생은 매우 적다면?
  * 여벌의 체육복을 가져온 학생들의 번호(reserve)를 정렬하고
  * 이것을 하나하나 순서대로 살펴보면서
  * `빌려줄 수 있는 다른 학생을 찾아`서 처리(나보다 -1인 학생, +1인 학생 찾기)
  * 정렬 복잡도 O(klogk)지만 매우 적은 경우엔 이 방법을 택하는게 더 좋을 것
  * 빌려줄 수 있는 다른 학생 찾기 => 해시를 적용해 상수시간에 처리

![image-20220711173004155](.\images\image-20220711173004155.png)



### 복잡도

* 여벌 체육복 가져온 학생들 번호 (reserve) 정렬 => O(klogk)
* 체육복 빌려줄 수 있는 학생들 처리 => O(k) x O(1) (앞뒤 학생 체크 => 해시 테이블)
* 전체 알고리즘 시간 복잡도 `O(klogk)`
* 전체n은 매우크지만 reserve의 길이(k)가 매우 적을 때만 적용가능



## 새로 알게된 것

1. 배열 초기화
   * u[i-1:i+1] = [1, 1]