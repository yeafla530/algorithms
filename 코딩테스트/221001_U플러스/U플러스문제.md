# U플러스

## 2.

꽤 사골문제

a ( * ) => *를 a만큼 반복해라

중첩등장 가능 

3(r2(h)s)라면 rhhsrhhsrhhs로 복원가능



ex ) 2(rhs3(hello)) 

1. 숫자들을 문자열에서 제거

   (rhs(hello)) 

2. 괄호가 열리는 부분에 대해 정의

   2-1. 여는괄호 : 반복되는 횟수

   2-2. 닫는 괄호 : 여는 괄호와 쌍을 이루는 인덱스를 기록

   2-3. (2, 11) => 2번 반복되고 닫는괄호는 11번째 index에 있다

3. 재귀함수 만들기

   construct (pattern, pairs, L, R) => patterns에서 L번째부터 R번째를 복원하는 결과함수

   construct(new, pairs, 0, len(new)-1) =>처음부터 끝까지 복원해줘!

4. for i in pattern[L...R]

   ​	pattern[i] = 알파벳

   ​	or 

   ​	pattern[i] = "("  => 닫는괄호 위치를 찾고 안쪽 내부에 대해서 구성결과 복원

![image-20221002142103783](.\images\image-20221002142103783.png)

![image-20221002141835647](.\images\image-20221002141835647.png)



ex) 287(ab84(c)82(d))

val = 0 * 10 + 2 = 2 / 2 * 10 + 8 = 28 / 28 * 10 + 7 = 287

중첩되는 괄호가 있기 때문에 재귀가 편하다



## 3.

마냥 쉬운문제 아니다,,

범위는 n, m = 4

지하철 n행 m열에 걸쳐 사람들이 앉아있음

각자원하는 방향으로 앉아있음

마주앉은 사람 중 최소 몇명이 움직여야 모두가 마주보지 않을 수 있을까

![image-20221002142835073](.\images\image-20221002142835073.png)

![image-20221002142937830](.\images\image-20221002142937830.png)

90도 회전은 최소 4명이 회전해줘야 모두 마주보지 않을 수 있다

그리디하면 문제를 풀 수 있을까?

그리디의 무서운 점은 내가 찾은 방법이 정말 최소 횟수냐?를 보장할 수 없다

그리디로 정답이 나온 분들은 데이터가 약해서 맞은걸 수 있다



### 완전탐색 진행

3개가 마주보고 있다면 최소한 3번은 회전해야한다 => 참

![image-20221002143325663](.\images\image-20221002143325663.png)

K개의 쌍이 마주보고 있다면 최소 K번은 움직여야 된다 => 이런 사실을 가지고 가지치기 

Branch & Bound

**풀이**

1. 문제가 되는 쌍을 디텍션 함 (전부 찾음)

   ![image-20221002143530933](.\images\image-20221002143530933.png)

2. 시계방향, 반시계방향으로 회전 시켜봄

   다시 문제되는 애중 하나 회전시켜봄

   ![image-20221002143618520](.\images\image-20221002143618520.png)

3. 재귀를 반복해서 모두 마주보지 않을때까지 진행 => 횟수 찾아냄

4. 모두가 마주보고 있는 경우 백트레킹은 경우의 수에 약하다

   ![image-20221002143736585](.\images\image-20221002143736585.png)

   어떻게 하면 불필요한 탐색을 하지 않을 수 있을까가 키포인트

![image-20221002143807612](.\images\image-20221002143807612.png)

toward : 특정위치에서 바라보고 있는 좌표를 알려줌

![image-20221002143858857](.\images\image-20221002143858857.png)

is_facing : 서로 바라보고 있는지 확인

![image-20221002143953790](.\images\image-20221002143953790.png)

detect : 문제를 일으키는 친구 찾기, 

hash : 2차원 행렬을 숫자 하나로 바꿔줘서 1:1 hashing되도록 함

![image-20221002144017453](.\images\image-20221002144017453.png)

4진법으로 생각한다 두개가 똑같은 코드

![image-20221002144223822](.\images\image-20221002144223822.png)

i, j가 격자를 벗어나면 무시해줌

![image-20221002144315453](.\images\image-20221002144315453.png)

![image-20221002144358683](.\images\image-20221002144358683.png)

**hash설명**

숫자가 쓰여있어도 4진법으로 표현하면 2차원 배열을 숫자로 표현할 수 있게된다

![image-20221002144532961](.\images\image-20221002144532961.png)

똑같은 친구를 탐색한 적이 있다면 불필요한 탐색인 경우 멈춤

마지막 가지치기가 중요

내가 지금까지 count번 회전하고 남은 쌍이 K개라면 더한값이 지금까지 찾은 답보다 크다면 가지치기

![image-20221002144824307](.\images\image-20221002144824307.png)

6번을 움직여서 3쌍만 남겨놓음

근데 이전 완탐을 하면서 8번만에 모두가 마주하지 않은 방법이 존재했었다

3쌍을 마주보지 않게 하려면 6 + 3 = 9번을 움직여야함

8 < 9이므로 굳이 움직이지 않아도 됨

![image-20221002145402742](.\images\image-20221002145402742.png)

![image-20221002145528999](.\images\image-20221002145528999.png)



## 4.

토너먼트 경기를 함 

1군팀들 2군팀들 토너먼트 진행

1군과 2군이 마주치면 1군이 이김

1군이 포함된 경기(1군과 1군, 1군과 2군) 횟수를 알고 싶음

또한 2군 팀들 중에서 한군을 1군으로 바꾸고 싶음



![image-20221002145803519](.\images\image-20221002145803519.png)

새로운 대진표에서는 아까 말한 조건이 2번 더 생겨 6번이됨



![image-20221002145912815](.\images\image-20221002145912815.png)

어떤 팀을 바꿔야 경기 횟수가 많아지나

팀의 개수는 13만개 정도



힙을 직접 구현한 사람이라면 쉽게 풀었을 수 있다

핵심 아이디어가 힙 

1. 대진 트리를 직접 만든다

2. 트리 번호를 매겨준다

![image-20221002150202930](.\images\image-20221002150202930.png)

3. 8번 인덱스부터 시작, 2번째는 4번부터 시작 
4. 131072가 대결한다면 131072번이 시작이될것이다
5. 부모노드는 현재 노드를 2로 나눈 것 
6. 왼쪽 자식노드는 * 2, 오른쪽 자식 노드는 * 2 +1

![image-20221002150428315](.\images\image-20221002150428315.png)

![image-20221002150523821](.\images\image-20221002150523821.png)

1. 기존 대전수를 count해준다
2. 2를 하나씩 다 바꿔본다 

![image-20221002150717584](.\images\image-20221002150717584.png)



### 코드

![image-20221002150809857](.\images\image-20221002150809857.png)

n번지부터 차례대로 단말 노드를 채워준다

B = base number



왼쪽자식과 오른쪽 자식중 누가 우승하는지 적어주게됨 (더 큰값)

둘이 싸웠는데 1군이 이겼다는건 특별한 대전이었으니 + 1 해준다

![image-20221002150936089](.\images\image-20221002150936089.png)

모든 단말노드를 보면서 2군을 1군으로 변경해본다

cur = 부모로 올려줌, change_cnt = 특별한 대전 개수

![image-20221002151227800](.\images\image-20221002151227800.png)