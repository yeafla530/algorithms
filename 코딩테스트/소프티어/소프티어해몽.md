# 소프티어 1번

N개의 나무 <= *10만개* 가 있는데

7 10 6 14 

B만큼의 비료 <= 10**18 가 있을때 

가장 낮은 나무의 높이 <= 10**9 가 가장 높아지길 바랄때

비료를 h만큼 성장시키고 싶다면 비료를 h***2만큼* 써야함



최솟값의 최댓값 *->* 이분탐색!!



### 나이브한 풀이

1. 가장 낮은 나무의 높이를 *1씩* 높여야함

=> 시간안에 모든 비료를 쓰는게 불가능

=> 10***9번* 높여야한다



### 다른 생각

1. 모든 나무 *7이상이* 되는지 확인 

![image-20220907121004729](C:\Users\이예림\AppData\Roaming\Typora\typora-user-images\image-20220907121004729.png)

2. 나이브하게 1씩 증가시키면서 확인하면 시간초과가 남 => 파라미터 서치 사용
3. 1 <= H <= 20억
4. 모든 나무 10억 이상 만드는게 가능해 => Yes 라면 10억까진 일일히 확인할 필요가 없어짐
5. 10억 <= H <= 20억
6. 15억이상 가능해? => No
7. 대략 30번정도의 질문만에 풀이가 가능해짐

```
import sys

si = sys.stdin.readline
N, B = map(int, si().split())
a = list(map(int, si().split()))

def slove(H: int) -> bool:
    # 모든 나무의 높이가 H 이상이도록 할 수 있는가? O(N)
    need = 0
    for x in a:
        if x >= H: # 이미 나무가 H이상이면, 비료 사용할 필요 없음
            continue
    
        need += (H - x) * (H - x)
    
    return need <= B

L, R, ans = 1, 2e9, 0 #(log 20억)
while L <= R:
    mid = (L + R) // 2
    if solve(mid):
        ans = mid
        L = mid + 1
    
    else:
        R = mid - 1
    

print(ans)
```



---

# 소프티어 2번

### 애드혹 문제

i < j < k

4 2 5 3 1

N <= 5000인 버전의 풀이, N이 100인풀이, N이 10만인 풀이

1. N = 100

   for문 사용=> N**3

2. N = 5000 => 세제곱하면 시간초과가 걸릴것임 1억이 넘어서

   1. j만 골라라=> i와 k는 독립적으로 고를 수 있음

   2. j의 왼쪽에 오른쪽에 몇개가 있는지 확인하여 2*2만큼의 수가 조합의 수인걸 알 수 있음

   3. j : 첫번째 원소는 0가지, 두번째 원소는 0*1 = 0, 세번째 원소 2x2 = 4

      4번쨰 원소 1x1 = 1

   4. j는 O(N^2)만에 문제를 풀 수있음

3. N = 10만

   1. j를 순서를 잘 써서 왼쪽과 오른쪽작은걸 NlogN만의 시간을 쓸 수 있다

   2. 사용되는 자료구조가 세그먼트 트리라고 취준 레벨에서는 배우지 않는다

   3. j를 어떤 순서로 보느냐가 핵심이 될것임

      

```
import sys
si = sys.stdin.readline
N = int(si())
a = list(map(int, si().split()))
psum = [0 for _ in range(N + 1)]
ans = 0
for j in range(N):
	if j > 0:
		for k in range(j + 1, N):
			if a[j] < a[k]:
				continue
			ans += psum[a[j] - 1] - psum[a[k]]
		
	for num in range(a[j], N + 1):
		psum[num] += 1
		
print(ans)
```

